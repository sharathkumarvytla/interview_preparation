# Array
- Array represent group of indivual objects in single array
- Array will allow only homogenius datatype elements but not possible to represent hetrogenius datatype elements in array
- Array doesn't have any underline data structures, means array doesn't maintain any data structure, so array dont have any readymade(pre deffind) methods
Ex: String[] array=new String[2];
  array[0]="A"; 
  array[1]="B";

- Doesn't support Hetrogenuis values
  Student[] st=new Student[3];
  st[0]=new Student(); \\ accept homogenius means same type object will accept
  st[1]=new Employee(); \\ we get error

# Diff Arrays vs Collections
- Array is fxed size, Collection is growable nature
- Array can allow only homogenius datatype elements, Collections can allow both homogenius and hetrogenius elements
- Array doesn't maintain any underline datastructuresm, Collections every class maintain underline data structure
- Array can hold both primitives and object types, Collections can hold only object types
- Performance wise Arrays is recomended, Collections are not recomended

# Collections
- Collections is an framework, collections framework contains collection of classes and interface. It is used to store the data efficiently and we can perform searching, 
  inserting updating and deleting operations using methods very easily
- We have different interfaces in collection
1. List
2. Set
3. Queue

# List
- List is an interface, It is used to insert the element and no required to give an array size and array only can increase array size dynamically
- List can allow duplicate value and null values, and list can fallow insertion order
- We can do inser, update, delete and get operation very easily using predefined methods. List interface contains 3 classes
1. ArrayList 2. LinkedList 3. Vector
1. ArrayList
- ArrayList is a class impementd by List interface
- While adding or remove values in ArrayList in the midle of object,   remaining values will be shifted into next index 
- Arraylist can allow multiple null value 
- Arraylist can follow insertion order
- ArrayList is a non synchronized, so Arraylist is not thread safe
- sort() : used to sort element in ArrayList object
Ex: ArrayList<String> listInfo=new ArrayList<String>
    listInfo.add("C")
    listInfo.add("A") 
    listInfo.add("B") 
    Collections.sort(listInfo)

- reverseOrder(): used to change arraylist in reverse
Ex: ArrayList<String> listInfo=new ArrayList<String>
    listInfo.add("A")
    listInfo.add("B") 
    listInfo.add("C") 
    Collections.reverseOrder(listInfo)

1) add( Object o): This method adds an object o to the arraylist.
obj.add("hello");
This statement would add a string hello in the arraylist at last position.

2) add(int index, Object o): It adds the object o to the array list at the given index.
obj.add(2, "bye");
It will add the string bye to the 2nd index (3rd position as the array list starts with index 0) of array list.

3) remove(Object o): Removes the object o from the ArrayList.
obj.remove("Chaitanya");
This statement will remove the string “Chaitanya” from the ArrayList.

4) remove(int index): Removes element from a given index.
obj.remove(3);
It would remove the element of index 3 (4th element of the list – List starts with o).

5) set(int index, Object o): Used for updating an element. It replaces the element present at the specified index with the object o.
obj.set(2, "Tom");
It would replace the 3rd element (index =2 is 3rd element) with the value Tom.

6) int indexOf(Object o): Gives the index of the object o. If the element is not found in the list then this method returns the value -1.
int pos = obj.indexOf("Tom");
This would give the index (position) of the string Tom in the list.

7) Object get(int index): It returns the object of list which is present at the specified index.
String str= obj.get(2);
Function get would return the string stored at 3rd position (index 2) and would be assigned to the string “str”. We have stored the returned value in string variable because in our example we have defined the ArrayList is of String type. If you are having integer array list then the returned value should be stored in an integer variable.

8) int size(): It gives the size of the ArrayList – Number of elements of the list.
int numberofitems = obj.size();
9) boolean contains(Object o): It checks whether the given object o is present in the array list if its there then it returns true else it returns false.
obj.contains("Steve");
It would return true if the string “Steve” is present in the list else we would get false.

10) clear(): It is used for removing all the elements of the array list in one go. The below code will remove all the elements of ArrayList whose object is obj.
obj.clear();


2. Linked List
- Linkedlist is a class implement by List interface
- In lnkedlist every element as on node, means can have two point. 1 is data and 2 is reference of next node. so while insert value in linkedlist just reference only can change but not changed/shipted remaining element
- Linked list can allow multiple null value 
- LinkedList can follow insertion order
- LinkedList is a non synchronized, Linked list is not thread safe

Ex: LinkedList<String> listInfo=new LinkedList<String>
    listInfo.add("C")
    listInfo.add("A") 
    listInfo.add("B") 
    Collections.sort(listInfo)

- reverseOrder(): used to change arraylist in reverse
Ex: LinkedList<String> listInfo=new LinkedList<String>
    listInfo.add("A")
    listInfo.add("B") 
    listInfo.add("C") 
    Collections.reverseOrder(listInfo)

- Convert LinkedList to ArrayList
  List<String> list=new ArrayList<String>(listInfo);

1) boolean add(Object item): It adds the item at the end of the list.
llistobj.add("Hello");
It would add the string “Hello” at the end of the linked list.

2) void add(int index, Object item): It adds an item at the given index of the the list.
llistobj.add(2, "bye");
This will add the string “bye” at the 3rd position( 2 index is 3rd position as index starts with 0).

3) boolean addAll(Collection c): It adds all the elements of the specified collection c to the list. It throws NullPointerException if the specified collection is null. Consider the below example –
LinkedList<String> llistobj = new LinkedList<String>();
ArrayList<String> arraylist= new ArrayList<String>();
arraylist.add("String1");
arraylist.add("String2");
llistobj.addAll(arraylist);
This piece of code would add all the elements of ArrayList to the LinkedList.

4) boolean addAll(int index, Collection c): It adds all the elements of collection c to the list starting from a give index in the list. It throws NullPointerException if the collection c is null and IndexOutOfBoundsException when the specified index is out of the range.
llistobj.add(5, arraylist);
It would add all the elements of the ArrayList to the LinkedList starting from position 6 (index 5).

5) void addFirst(Object item): It adds the item (or element) at the first position in the list.
llistobj.addFirst("text");
It would add the string “text” at the beginning of the list.

6) void addLast(Object item): It inserts the specified item at the end of the list.
llistobj.addLast("Chaitanya");
This statement will add a string “Chaitanya” at the end position of the linked list.

7) void clear(): It removes all the elements of a list.
llistobj.clear();
8) Object clone(): It returns the copy of the list.

For e.g. My linkedList has four items: text1, text2, text3 and text4.

Object str= llistobj.clone();
 System.out.println(str);
Output: The output of above code would be:

[text1, text2, text3, text4]

9) boolean contains(Object item): It checks whether the given item is present in the list or not. If the item is present then it returns true else false.
boolean var = llistobj.contains("TestString");
It will check whether the string “TestString” exist in the list or not.

10) Object get(int index): It returns the item of the specified index from the list.
Object var = llistobj.get(2);
It will fetch the 3rd item from the list.

11) Object getFirst(): It fetches the first item from the list.
Object var = llistobj.getFirst();
12) Object getLast(): It fetches the last item from the list.

Object var= llistobj.getLast();
13) int indexOf(Object item): It returns the index of the specified item.
llistobj.indexOf("bye");

14) int lastIndexOf(Object item): It returns the index of last occurrence of the specified element.
int pos = llistobj.lastIndexOf("hello);
integer variable pos will be having the index of last occurrence of string “hello”.

15) Object poll(): It returns and removes the first item of the list.
Object o = llistobj.poll();
16) Object pollFirst(): same as poll() method. Removes the first item of the list.
Object o = llistobj.pollFirst();

17) Object pollLast(): It returns and removes the last element of the list.
Object o = llistobj.pollLast();

18) Object remove(): It removes the first element of the list.
llistobj.remove();

19) Object remove(int index): It removes the item from the list which is present at the specified index.
llistobj.remove(4);
It will remove the 5th element from the list.

20) Object remove(Object obj): It removes the specified object from the list.
llistobj.remove("Test Item");

21) Object removeFirst(): It removes the first item from the list.
llistobj.removeFirst();

22) Object removeLast(): It removes the last item of the list.
llistobj.removeLast();

23) Object removeFirstOccurrence(Object item): It removes the first occurrence of the specified item.
llistobj.removeFirstOccurrence("text");
It will remove the first occurrence of the string “text” from the list.

24) Object removeLastOccurrence(Object item): It removes the last occurrence of the given element.
llistobj.removeLastOccurrence("String1);
It will remove the last occurrence of string “String1”.

25) Object set(int index, Object item): It updates the item of specified index with the give value.
llistobj.set(2, "Test");
It will update the 3rd element with the string “Test”.

26) int size(): It returns the number of elements of the list.
llistobj.size();

# ArrayList Vs Linked List
- Arraylist is best choice for seaching elements from arraylist object, bcoz arraylist can maintain index based machanisum, so arraylist can return value fastely
- Linkedlist is best choice for insertion and delete elements from linkedlist, bcoz in linkedlist every element is one node, so node can maintain data and reference   address. while insert or delete elements just node reference only can changes, but not shipted elements

3. Vector
- Vector is a class implemented by List interface
- Vector is same like Arraylist only, but Arraylist is non-synchronized(non thread safe) and Vector is synchronized(thread safe)
- Whenever Arraylist Exceed maxsize then automaticaly increase 50% of capacity, but in vector increase 100% of capacity
- Comapre to Arraylist Vector is very slow to perform seraching operations, bcoz vector is thread safe
Ex: Vector<String> listInfo=new Vector<String>
    listInfo.add("C")
    listInfo.add("A") 
    listInfo.add("B") 
Ex: Vector<String> listInfo=new Vector<String>
    listInfo.add("A")
    listInfo.add("B") 
    listInfo.add("C") 
    Collections.reverseOrder(listInfo)

1. void addElement(Object element): It inserts the element at the end of the Vector.
2. int capacity(): This method returns the current capacity of the vector.
3. int size(): It returns the current size of the vector.
4. void setSize(int size): It changes the existing size with the specified size.
5. boolean contains(Object element): This method checks whether the specified element is present in the Vector. If the element is been found it returns true else false.
6. boolean containsAll(Collection c): It returns true if all the elements of collection c are present in the Vector.
7. Object elementAt(int index): It returns the element present at the specified location in Vector.
8. Object firstElement(): It is used for getting the first element of the vector.
9. Object lastElement(): Returns the last element of the array.
10. Object get(int index): Returns the element at the specified index.
11. boolean isEmpty(): This method returns true if Vector doesn’t have any element.
12. boolean removeElement(Object element): Removes the specifed element from vector.
13. boolean removeAll(Collection c): It Removes all those elements from vector which are present in the Collection c.
14. void setElementAt(Object element, int index): It updates the element of specifed index with the given element.

# ArrayList Vs Vector
- Arraylist is non synchronized(non thread safe), but Vector is synchronized((thread safe)
- Arraylist will increase capacity 50% while exceed capacity, but vector is increase 100% capacity
- Arraylist if fast bcoz it is non synchronize, but Vector is slow bcoz vector is synchronized
Note : Synchronized means only one thread can allow to perform at same time, reamaining thread will wait untill currect thread execution is complete

# Set
- Set is an interface, It is used to insert the element and no required to give an array size and array only can increase array size dynamically
- Set coudn't allow duplicate value and null values allow only one time, and list coudn't fallow insertion order
- We can do insert, update, delete and get operation very easily using predefined methods. List interface contains 3 classes
1. HashSet 2. LinkedHashSet 3. TreeSet
1. HashSet
- HashSet is a class impementd by Set interface
- HashSet coudn't allow duplicate values and null can allow only one time
- HashSet coudn't  follow insertion order, randomly return values
- Hashset is a non synchronized, so HashSetis not thread safe

1.boolean add(Element  e): It adds the element e to the list.
2.void clear(): It removes all the elements from the list.
3.Object clone(): This method returns a shallow copy of the HashSet.
4.boolean contains(Object o): It checks whether the specified Object o is present in the list or not. If the object has been found it returns true else false.
5.boolean isEmpty(): Returns true if there is no element present in the Set.
6.int size(): It gives the number of elements of a Set.
7.boolean(Object o): It removes the specified Object o from the Set.

2. LinkedHashSet
- LinkedHashSet is a class impementd by Set interface
- LinkedHashSet coudn't allow duplicate values and null can allow only one time
- LinkedHashSet can  follow insertion order, and return same order
- Hashset is a non synchronized, so HashSetis not thread safe

2. TreeSet
- TreeSet is a class impementd by Set interface
- TreeSet coudn't allow duplicate values and null can allow only one time
- TreeSet can follow ascending order, and return ascending order
- Hashset is a non synchronized, so HashSet is not thread safe

# Diff HashSet Vs LinkedHashSet
- Only different is HashSet could not follow insertion order, randomly return values, but LinkedHashSet follow insertion order and return same order

# Diff HashSet Vs TreeSet
- Only different is HashSet could not follow insertion order, but TreeSet follow ascending order

# Map
- Map is an interface, It is used store values in key and value pair
- Every map object can allow duplicate value but could not allow duplicate keys
- Map interface contains 3 implemented classes
1. HashMap, 2. LinkedHashMap 3.TreeMap

1.HashMap
- HashMap is implemented class by Map inteface
- HashMap can insert value in key values fair, but coudn't follow any order
- HashMap is non sychronized (not in thread safe)
- HashMap coudn't accept duplicate key but values can duplicate

1. void clear(): It removes all the key and value pairs from the specified Map.
2. Object clone(): It returns a copy of all the mappings of a map and used for cloning them into another map.
3. boolean containsKey(Object key): It is a boolean function which returns true or false based on whether the specified key is found in the map.
4. boolean containsValue(Object Value): Similar to containsKey() method, however it looks for the specified value instead of key.
5. Value get(Object key): It returns the value for the specified key.
6. boolean isEmpty(): It checks whether the map is empty. If there are no key-value mapping present in the map then this function returns true else false.
7. Set keySet(): It returns the Set of the keys fetched from the map.
8. value put(Key k, Value v): Inserts key value mapping into the map. Used in the above example.
9. int size(): Returns the size of the map – Number of key-value mappings.
10. Collection values(): It returns a collection of values of map.
11. Value remove(Object key): It removes the key-value pair for the specified key. Used in the above example.
12. void putAll(Map m): Copies all the elements of a map to the another specified map.

2.TreeMap
- TreeMap is implemented class by Map inteface
- TreeMap can insert value in key values fair, and it can follow some sorting(ascending) order
- TreeMap is non sychronized (not in thread safe)
- TreeMap coudn't accept duplicate key but values can duplicate

3.LinkedHashMap
- LinkedHashMap is implemented class by Map inteface
- LinkedHashMap can insert value in key values fair, and it can follow insertion order
- LinkedHashMap is non sychronized (not in thread safe)
- LinkedHashMap coudn't accept duplicate key but values can duplicate

4. HashTable
- HashTable is implemented class by Map inteface
- HashTable can insert value in key values fair, and it coudn't follow insertion order
- HashTable is sychronized (thread safe)
- HashTable coudn't accept duplicate key but values can duplicate and coudn't allow null keys

# Itearator and ListIterator
- Both are used to iterate object, but Iterator is iterate only forword directions only and ListIterator is used to iterte forward and backward directios
Ex:
-  List<String> listObject = new ArrayList<String>();
      listObject.add("India");
      listObject.add("Australia");
      listObject.add("England");
      Iterator it = listObject.iterator(); // It will work only forward direction
      while (it.hasNext()) {
         System.out.println(it.next());
      }

- List<String> listObject = new ArrayList<String>();
      listObject.add("Java");
      listObject.add("Selenium");
      ListIterator it = listObject.listIterator(); //It will work only forward and backword direction
      while (it.hasNext()) {
         System.out.println(it.next());
      }
     while (it.hasPrevious()) {
         System.out.println(it.next());
      }

# How to change HashMap is synchronized
- We can change HashMap as synchronized using synchronizedMap method
Ex:  HashMap<Integer, String> hmap= new HashMap<Integer, String>();
         hmap.put(2, "Anil");
         hmap.put(44, "Ajit");
         hmap.put(1, "Brad");
         Map map= Collections.synchronizedMap(hmap);

- We can change ArrayList as synchronized using synchronizedList method
Ex:  ArrayList<Integer, String> hmap= new ArrayList<Integer, String>();
         hmap.put(2, "Anil");
         hmap.put(44, "Ajit");
         hmap.put(1, "Brad");
         List map= Collections.synchronizedList(hmap);

# Comparable And Comparator
- Comparable and Comparator are interfaces, both are used to sorting values
- Comparable provide single sorting, but Comparator provie multiple sortings
Ex:

- Comparable
  public class TechInfo implements Comparable<TechInfo>{
	private String techId;
	private String techName;
	private String duration;
	public TechInfo(String techId, String techName, String duration) {
		super();
		this.techId = techId;
		this.techName = techName;
		this.duration = duration;
	}
	// setters and getters
	public int compareTo(TechInfo o) {
		if(getDuration().equals(o.getDuration()))
		return 1;
		else
		return -1;
	}

- Comparator
  public class Test2 {
  public static void main(String[] args) {		
		List<TechInfo> listInfo=new ArrayList<TechInfo>();
		listInfo.add(new TechInfo("101","Java","90"));
		listInfo.add(new TechInfo("102","Puthon","80"));
		listInfo.add(new TechInfo("103","DataScience","60"));
		listInfo.add(new TechInfo("104","Angular","50"));
		listInfo.add(new TechInfo("105","Oracle","30"));
		Comparator<TechInfo> com=new Comparator<TechInfo>(){
			public int compare(TechInfo o1, TechInfo o2) {
				if(o1.getDuration().equals(o2.getDuration()))
					return 1;
				else
				return 0;
			}
		};
		
		Collections.sort(listInfo, com);
		for(TechInfo info:listInfo){
			System.out.println("Id "+info.getTechId()+" Name "+info.getTechName()+" Duration "+info.getDuration());
		}
	}



