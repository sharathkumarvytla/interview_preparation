HashCode
- For every object a unique number generated by JVM, which is nothing but hashcode
- Hashcode wan't represent address of object
- JVM will use hashcode while saving objects into hashing related data structures like hashtable, hashmap, hashset ect
- The main advantage of saving objects based on objects is seach operation will become easey( the most powerfull search algarithm upto today is hashing)

Exception hanling
- Java.lang.Object is super object of all java objects
- Java.lang.Throwable is root class of all exceptions
- We can't handle error while programing will accured errors
- We have two types of exceptions checked and un-checked exception
- At the time of compilere will check then it is checked exception
- At the time of runtime will check the is it un checked exception
- We can handle both checked and unchecked exception using try{},catch(Exception e){} and finally{} block

final, finally and finalize
- final is modifier used for class level, method level and variable level
- finally is block always associated with try and catch, we can write clean up activities in finally block
- finalize is a garbase collection method, used to cleanup objects

Throw keyword
- Some time we need to create exception explicitly then we go for use throw statement
Ex:pulbic class Test{
   public static void main(String[] args){
   try{
   System.out.println("Explicite exception throw")
   throw new ArithmeticException();
   }catch(ArithmeticException e){
   e.printStack();
   }
  }
 }

Throws keyword
- While accured checked exception, we must be hangle exception using try catch block
- Other wise we can throws the checked exception using throws keyword
- Throws statement will applicable for only checked exception, if we use for unchecked exeception no use of that

MultiThreading
- Execute multiple task simultaniously then we use it
- Two types of mutithreading 1. Process based and 2. Thread based
- Process based multithreads is execute multiple threads simultaniusly in independently
- Thread based multithread is execute multiple threads simultaniusly in independently in same programe

Thread Scheduler
-Thread scheduler will decide to which thread is execute first

start() and run()
-start() method will create new thread and execute run() inside execution
-run() method will not create new thread execute run() normally

Thread states
- Once we create new thread then it is new state
- Once call start() method then it is entered into ready(or)runnable state
- Once Thread scheduler will assign CPU then it is running state
- After execute run() method then it is entered into dead state

Yield()
- It is used to pause the current thread execution and give chance to execute remaining waitting thread of same priority
- If no threads waiting state then same thread will execute

Join()
- It is used to wait current thread untile complete speicific thread execution then we use it
- Join() will throws Interrupted exception is a checked exception, so we must be write join() within try and catch only

Sleep()
- If we want to pause/stop execution of thread for some amount of time then we use sleep()

Synchronized
- It is a keyword we can use it for method level and block level
- Synchronized can allow only one thread at a time
- While using synchronized intenally follow lock mechanisium

- Class level lock and Object level lock
- If thread will get Class level lock then thread will execute static synchronized methods, once execution completed then lock will release from thread
- If thread will get object level lock then thread will execute synchronized methods, once execution completed then lock will release from thread

Synchronized block
- While using synchronized for method, that entire method will wait for until current thead executin will complete, so it is not recomeded to use
- That's why we have option to use synchronized block concept
- Synchronized blocks are used to allow only one thread at a time for block execution 

Dead lock
- While multiple thread will be locked eachother
- Like thread-1 is locked with thread-2, thread-2 is locked with thread-3, and thread-3 is locked with thread-1
- overcome this problem, we must ignore to give lock for multiple threads, we should five lock for only importante threads, and instead of lock we use join method
