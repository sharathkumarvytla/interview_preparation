<<<<<<< Updated upstream
# Why Java is not 100% Object-Oriented?
- Java is not 100% Object-Oriented, becuase in java we have primitive type data types like boolean, byte, char, int, float, double, long, short. this all are not a objects. But we can convert primitive to object using wrapper class
- Also in java we have static methods and static variables, this are not belong to objects. Its belongs to class. becuase we can call static methods or static variables without creating objects

# Why ponters are not used in java?
- Basically pointers are unsafe, and increase the complexity of the program, In Java JVM is responsible for implicity memory allocation so required to use pointers

# What is JIT?
- JIT stands for Just-In-Time, Java compiler will convert java code(file.java) to byte code. JVM will read byte code line by line and convert(interprete) into machine language, JIT will read byte code very faster compare to JVM

# Why String is immutable?
- Immutable is like we cann't change values, String is immutable becauase once we assign value to String we cann't change value, If we try to change value internally will create new object for new value.
- Basically we are using String object for cradentials, URL Details, and storing confidential data so for security reasons String was immutable
- While assign value for String object, it will check already exist in string pool or not, if not then create new object other wise return exist string reference only
- But we can change String is mutable using String Buffer and String Builder

# What is Marker Interface?
- In marker interface doesn't have any methods and field. It is empty interface
- It is used to provide the metadata to a class while implement this inteface
- While implement marker interface, interface will tell to JVM this class is Serializable and Clonnable
  Ex: Public class MyClass implements Serializable { }
- We can create custom marker interface using annotation also like
  Ex: @MyMarker
      Public class MyClass { }

# Can we override a private or static method in Java?
- We can't override private or static method in java
- We can't access private methods from out side of class, so we cann't over ride private method
- We can't override static method becuase if we use same method name, parameters and return type in child class then it will hide the superclass method, it is called method hiding
  Ex: class Parent {
    static void display() {
        System.out.println("Parent's static method");
    }
  }

  class Child extends Parent {
    static void display() {  // This is method hiding, not overriding.
        System.out.println("Child's static method");
    }
  }

  public class Main {
    public static void main(String[] args) {
        Parent obj1 = new Parent();
        obj1.display();  // Output: Parent's static method

        Parent obj2 = new Child();
        obj2.display();  // Output: Parent's static method (method hiding, not overriding)

        Child obj3 = new Child();
        obj3.display();  // Output: Child's static method
    }
  }

# Does "finally" always execute in Java?
- Only for two cases not executed finally block like 
  1. If we use System.exit(), then it will terminate means will not execute next line
  2. Some time JVM will crash or get StockOveFlow Error then finally block will not execute

# What methods does the objects class hava?
Method			Purpose
clone()	                Creates a copy of the object.
equals(Object obj)	Checks if two objects are equal.
finalize()		Cleanup before the object is garbage collected. (Deprecated since Java 9)
getClass()		Gets the runtime class of the object.
hashCode()		Returns a hash code for the object.
notify()		Wakes up a single thread waiting on this object's monitor.
notifyAll()		Wakes up all threads waiting on this object's monitor.
toString()		Returns a string representation of the object.
wait()			Causes the thread to wait until notified.

# How can we make a class immutable
- To make class as immutable we have to follow set of rules like
1. Declare the class final.
- So it can't be extended
2. Make all fields private and final.
- So we cann't access field directly
3. Initialize all fields in the constructor.
4. Provide getter methods (but no setter methods).
5. Use defensive copies for mutable fields.
Ex: public final class Person {
    private final String name;
    private final int age;
    private final Date birthDate;
    // Constructor to initialize the fields
    public Person(String name, int age, Date birthDate) {
        this.name = name;
        this.age = age;
        // Defensive copy of the mutable object
        this.birthDate = new Date(birthDate.getTime());
    }
    // Getter for name
    public String getName() {
        return name;
    }
    // Getter for age
    public int getAge() {
        return age;
    }
    // Getter for birthDate with defensive copy
    public Date getBirthDate() {
        return new Date(birthDate.getTime());
    }
  }

# What is singleon class in java and how can we make a class singleton?
- A Singleton class is a design pattern that ensures a class has only one instance in the entire application and provides a global point of access to that instance. This pattern is often used when you need to control 
  access to resources, such as database connections or logging.
- To make a class Singleton, we need to ensure the following:
1. Private constructor: To prevent instantiation from outside the class.
2. A static variable: To hold the single instance of the class.
3. A public static method: To provide access to the instance.
Ex: public class Singleton {
    // Step 1: Create a private static variable to hold the instance
    private static Singleton instance;
    // Step 2: Make the constructor private so that the class cannot be instantiated outside
    private Singleton() {
        // Private constructor to prevent instantiation
    }
    // Step 3: Provide a public static method to get the instance
    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton(); // Create the instance if it doesn't exist
        }
        return instance;
    }
  }
=======
# Why Java is not 100% Object-Oriented?
- Java is not 100% Object-Oriented, becuase in java we have primitive type data types like boolean, byte, char, int, float, double, long, short. this all are not a objects. But we can convert primitive to object using wrapper class
- Also in java we have static methods and static variables, this are not belong to objects. Its belongs to class. becuase we can call static methods or static variables without creating objects

# Why ponters are not used in java?
- Basically pointers are unsafe, and increase the complexity of the program, In Java JVM is responsible for implicity memory allocation so required to use pointers

# What is JIT?
- JIT stands for Just-In-Time, Java compiler will convert java code(file.java) to byte code. JVM will read byte code line by line and convert(interprete) into machine language, JIT will read byte code very faster compare to JVM

# Why String is immutable?
- Immutable is like we cann't change values, String is immutable becauase once we assign value to String we cann't change value, If we try to change value internally will create new object for new value.
- Basically we are using String object for cradentials, URL Details, and storing confidential data so for security reasons String was immutable
- While assign value for String object, it will check already exist in string pool or not, if not then create new object other wise return exist string reference only
- But we can change String is mutable using String Buffer and String Builder

# What is Marker Interface?
- In marker interface doesn't have any methods and field. It is empty interface
- It is used to provide the metadata to a class while implement this inteface
- While implement marker interface, interface will tell to JVM this class is Serializable and Clonnable
  Ex: Public class MyClass implements Serializable { }
- We can create custom marker interface using annotation also like
  Ex: @MyMarker
      Public class MyClass { }

# Can we override a private or static method in Java?
- We can't override private or static method in java
- We can't access private methods from out side of class, so we cann't over ride private method
- We can't override static method becuase if we use same method name, parameters and return type in child class then it will hide the superclass method, it is called method hiding
  Ex: class Parent {
    static void display() {
        System.out.println("Parent's static method");
    }
  }

  class Child extends Parent {
    static void display() {  // This is method hiding, not overriding.
        System.out.println("Child's static method");
    }
  }

  public class Main {
    public static void main(String[] args) {
        Parent obj1 = new Parent();
        obj1.display();  // Output: Parent's static method

        Parent obj2 = new Child();
        obj2.display();  // Output: Parent's static method (method hiding, not overriding)

        Child obj3 = new Child();
        obj3.display();  // Output: Child's static method
    }
  }

# Does "finally" always execute in Java?
- Only for two cases not executed finally block like 
  1. If we use System.exit(), then it will terminate means will not execute next line
  2. Some time JVM will crash or get StockOveFlow Error then finally block will not execute

# What methods does the objects class hava?
Method			Purpose
clone()	                Creates a copy of the object.
equals(Object obj)	Checks if two objects are equal.
finalize()		Cleanup before the object is garbage collected. (Deprecated since Java 9)
getClass()		Gets the runtime class of the object.
hashCode()		Returns a hash code for the object.
notify()		Wakes up a single thread waiting on this object's monitor.
notifyAll()		Wakes up all threads waiting on this object's monitor.
toString()		Returns a string representation of the object.
wait()			Causes the thread to wait until notified.

# How can we make a class immutable
- To make class as immutable we have to follow set of rules like
1. Declare the class final.
- So it can't be extended
2. Make all fields private and final.
- So we cann't access field directly
3. Initialize all fields in the constructor.
4. Provide getter methods (but no setter methods).
5. Use defensive copies for mutable fields.
Ex: public final class Person {
    private final String name;
    private final int age;
    private final Date birthDate;
    // Constructor to initialize the fields
    public Person(String name, int age, Date birthDate) {
        this.name = name;
        this.age = age;
        // Defensive copy of the mutable object
        this.birthDate = new Date(birthDate.getTime());
    }
    // Getter for name
    public String getName() {
        return name;
    }
    // Getter for age
    public int getAge() {
        return age;
    }
    // Getter for birthDate with defensive copy
    public Date getBirthDate() {
        return new Date(birthDate.getTime());
    }
  }

# What is singleon class in java and how can we make a class singleton?
- A Singleton class is a design pattern that ensures a class has only one instance in the entire application and provides a global point of access to that instance. This pattern is often used when you need to control 
  access to resources, such as database connections or logging.
- To make a class Singleton, we need to ensure the following:
1. Private constructor: To prevent instantiation from outside the class.
2. A static variable: To hold the single instance of the class.
3. A public static method: To provide access to the instance.
Ex: public class Singleton {
    // Step 1: Create a private static variable to hold the instance
    private static Singleton instance;
    // Step 2: Make the constructor private so that the class cannot be instantiated outside
    private Singleton() {
        // Private constructor to prevent instantiation
    }
    // Step 3: Provide a public static method to get the instance
    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton(); // Create the instance if it doesn't exist
        }
        return instance;
    }
  }

# Can we use HashMap in a multi-thread environment
- Yes. we can use HashMap in multi-thread environment, but we may get data inconsistency issue.becuase HashMap is not thread-safe so we may chance to execute multi threads in same bucket so deffinently data can be lost or overwritten
  If we want to wrap HashMap is thread-safe use Collection.synchronizedMap
- We can use ConcurrentHashMap in multi-thread environment, ConcurrentHashMap is thread-safe

# Is there any different in defining or creating a String by using String literal and by using the new() operator
- If we create String in String literal JVM will check Same value was exist or not in String Pool, If value exist then return same reference. If value not exist then create new String in String pool and return reference.
Ex: String s1 = "Hello";
- If we create String using new Operator String object will create in heap memory even that String is exists in String pool. If String value is exist in String pool also will create new object  

# What do you know about Factoy Design Pattern in Java

# What are the most important features of Java8
- Lambda Expression
- Stream API
- Default methods in the interface
- Static methods
- Functional Interface
- Optional
- Method Reference
- Date API
- Nashorn, JavaScript Engine

# What are the Spring Boot Starters
- Spring boot starters are pre-configured dependencies provided by spring boot to reduce the need for boilerplate dependency configuration.
- When we use this dependencies in pom.xml autoamtically it will download required dependencies for perficular module and we can quickly get up and running with minimal configuration 
- So developer no need to work on dependency configuration

# What is spring boot actuator
- Spring boot actuator is powerful feature in spring boot. It provide set of production-ready tool to monitor and manage application
- The key feature of actuator are
  1. Health Monitororing : Provides information about application health like (e.g,. Database connection, external APIs)
  2. Metrics : Exposes metrics about application perfomance like memory usage, active threads, and request count
  3. Environment Details : Display configuration properties, Environment Details and Profiles
  4. Application Insights: Includes detailed information about beans, request mappings, and thread dumps.
  5. Integration: Works seamlessly with monitoring tools like Prometheus, Grafana, ELK Stack, and New Relic. 
- Common Actuator Endpoints
Actuator exposes several endpoints, each providing specific information about the application. Some important endpoints include:
Endpoint	        Description
/actuator/health	Displays the health status of the application (e.g., "UP" or "DOWN").
/actuator/metrics	Shows application metrics like memory usage, CPU, and HTTP request statistics.
/actuator/info 		Displays custom application info (e.g., version, description).
/actuator/env		Exposes environment properties (e.g., application properties, system variables).
/actuator/beans		Lists all Spring beans in the application context.
/actuator/mappings	Shows all request mappings in the application.
/actuator/threaddump	Provides a thread dump of the JVM.
/actuator/loggers	Shows and allows configuration of application log levels.
 
# How do we configure same property with different values for different environments
- We have to maintain different types of property files like application-dev.property, application-prod.property, application-test.property. and have on activate any perticular property file in application.property file
  like spring.profiles.active=dev, spring.profiles.active=prod, spring.profiles.active=test
- Using @Profile annotaion we can manage environment like we have to create different datasource in configuration class
    @Configuration
    public class DataSourceConfig {
    @Bean
    @Profile("dev")
    public DataSource devDataSource() {
        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setUrl("jdbc:mysql://localhost:3306/dev_db");
        dataSource.setUsername("dev_user");
        dataSource.setPassword("dev_password");
        return dataSource;
    }

    @Bean
    @Profile("prod")
    public DataSource prodDataSource() {
        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setUrl("jdbc:mysql://localhost:3306/prod_db");
        dataSource.setUsername("prod_user");
        dataSource.setPassword("prod_password");
        return dataSource;
     }
    }
- In application.property file we need to activate any one of the environment like spring.profiles.active=dev, based on active value that bean only create

# What is AOP

# How can you access a value defined in the application? What is properties file in spring boot?
- We can inject property file values using @Value annotation, like
  propertiesfile:
  app.name=MySpringBootApp
  app.version=1.0.0

  @Component
  public class AppConfig {
  @Value("${app.name}")
  private String appName;
  @Value("${app.version}")
  private String appVersion;
  }

- And also we can access properties using @ConfigurationProperties, like
  app.properties:
  app.details.name=MySpringBootApp
  app.details.version=1.0.0
  app.details.owner=Sharath

  @Component
  @ConfigurationProperties(prefix = "app.details")
  public class AppDetailsConfig {

  private String name;
  private String version;
  private String owner;

  // Getters and Setters
  public String getName() { return name; }
  public void setName(String name) { this.name = name; }

  public String getVersion() { return version; }
  public void setVersion(String version) { this.version = version; }

  public String getOwner() { return owner; }
  public void setOwner(String owner) { this.owner = owner; }
  }

# How can you share your Rest endpoint API contracts with consumers of your applications
- We can share End point details with the help of swagger. Swagger will describing the structure of APIs. It is an open source service provided by Spring Boot

# How will we convert a monolithic to microservice application (16:20)

# How to make your microservices more Robust and fault tolerant

# How microservices can communicate each other
- We have two approaches to communicate microservices, like Synchronous & Asynchronous
- Synchronous communication : Rest Template, Web Client, Feign Client can be used for synchronous communication between two microservices
- Asynchronous communication : In this communication the client does not wait for a response, instead, it just send the message to the message broker. AMQP (like RebbitMQ)
  or Kafka can be used for asynchronous communication across microservices to achieve eventual consistency

# What are Joins in SQL?
- There are four types of SQL Joins
1. (Inner Joins) : It is used to retrieve the records that have matching values in both tables that are   involved in the join. Inner Join is mostly used to join queries
    - SELECT * FROM TABLE A JOIN TABLE B
    - SELECT * FROM TABLE A INNER JOIN TABLE B
2. Left(Outer Join) : Use for left join is to retrieve all the records or row from the left and the matched one from the right
    - SELECT * FROM TABLE_A A LEFT JOIN TABLE_B ON A.COL = B.COL
3. 





  